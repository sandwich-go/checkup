// Code generated by protokitgo. DO NOT EDIT.
// source: internal_command/internal_cmd.proto

package internal_command

import (
	// fixed import by protokitgo
	"context"
	"fmt"
	"math"
	"reflect"
	"strings"

	"bitbucket.org/funplus/ark"
	"bitbucket.org/funplus/sandwich/base/net/link"
	"bitbucket.org/funplus/sandwich/base/serror"
	"bitbucket.org/funplus/sandwich/base/validator"
	"bitbucket.org/funplus/sandwich/client"
	"bitbucket.org/funplus/sandwich/current"
	"bitbucket.org/funplus/sandwich/message"
	"bitbucket.org/funplus/sandwich/metadata"
	"bitbucket.org/funplus/sandwich/protocol/netutils"
	"bitbucket.org/funplus/sandwich/router"
	"google.golang.org/protobuf/proto"

	_ "google.golang.org/genproto/googleapis/api/annotations"
	protobufEmpty "google.golang.org/protobuf/types/known/emptypb"
	// dynamic import
)

// Reference imports to suppress errors if they are not otherwise used.
var _ ark.Context
var _ client.Client
var _ router.Router
var _ = current.NewContext(context.Background())
var _ serror.Error
var _ link.Session
var _ message.Message
var _ netutils.RawPacket
var _ ark.Context
var _ context.Context
var _ = fmt.Errorf
var _ = math.Inf
var _ proto.MarshalOptions
var _ reflect.Type
var _ strings.Builder
var _ metadata.MD
var _ protobufEmpty.Empty
var _ validator.Validator

type RpcClientInternalCmd interface {
	CmdPing(context.Context, *netutils.CmdPing, ...client.CallOption) (*netutils.CmdPingAck, error)
	CmdCheckup(context.Context, *netutils.CmdCheckup, ...client.CallOption) (*netutils.CmdCheckup, error)
	CmdBuildStream(context.Context, *CmdStream, ...client.CallOption) (*CmdStream, error)
}

type proxyRpcClientInternalCmd struct {
	c                     client.Client
	urinetutilsCmdPing    string
	urinetutilsCmdPingAck string
	urinetutilsCmdCheckup string
	uriCmdStream          string
	uriErrType            string
	usingGRPC             bool
}

// Deprecated: use NewRpcClientInternalCmd
var NewClientInternalCmdService = NewRpcClientInternalCmd

func NewRpcClientInternalCmd(c client.Client) RpcClientInternalCmd {
	cc := &proxyRpcClientInternalCmd{c: c}
	uri := c.Codec()
	cc.urinetutilsCmdPing = uri.URI(new(netutils.CmdPing))
	cc.urinetutilsCmdPingAck = uri.URI(new(netutils.CmdPingAck))
	cc.urinetutilsCmdCheckup = uri.URI(new(netutils.CmdCheckup))
	cc.uriCmdStream = uri.URI(new(CmdStream))
	cc.uriErrType = uri.URI(&netutils.ErrorResponse{})
	if v, ok := c.(interface {
		UsingGRPC() bool
	}); ok {
		cc.usingGRPC = v.UsingGRPC()
	}
	return cc
}
func (c *proxyRpcClientInternalCmd) CmdPing(ctx context.Context, in *netutils.CmdPing, opts ...client.CallOption) (*netutils.CmdPingAck, error) {

	if c.usingGRPC {
		ctx = context.WithValue(ctx, "context-key-grpc-uri", "/netutils.InternalCmd/CmdPing")
		ctx = context.WithValue(ctx, "context-key-grpc-response-pointer", new(netutils.CmdPingAck))
	}

	req := message.GetMessagePacket()
	req.Messages = message.Messages{&message.Message{Message: in, Uri: "/netutils.InternalCmd/CmdPing"}}

	req.Version = 1

	rsp, err := c.c.Call(ctx, req, opts...)

	message.PutMessagePacket(req)
	if err != nil {
		return nil, err
	}
	m0 := rsp.Messages[0]
	message.PutMessagePacket(rsp)

	if c.usingGRPC {
		if m0.Uri != c.urinetutilsCmdPingAck {
			return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.urinetutilsCmdPingAck)
		}
		return m0.Message.(*netutils.CmdPingAck), nil
	}
	if m0.Uri == c.uriErrType {
		return nil, m0.Message.(error)
	}

	if m0.Uri != c.urinetutilsCmdPingAck {
		return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.urinetutilsCmdPingAck)
	}
	return m0.Message.(*netutils.CmdPingAck), nil
}
func (c *proxyRpcClientInternalCmd) CmdCheckup(ctx context.Context, in *netutils.CmdCheckup, opts ...client.CallOption) (*netutils.CmdCheckup, error) {

	if c.usingGRPC {
		ctx = context.WithValue(ctx, "context-key-grpc-uri", "/netutils.InternalCmd/CmdCheckup")
		ctx = context.WithValue(ctx, "context-key-grpc-response-pointer", new(netutils.CmdCheckup))
	}

	req := message.GetMessagePacket()
	req.Messages = message.Messages{&message.Message{Message: in, Uri: "/netutils.InternalCmd/CmdCheckup"}}

	req.Version = 1

	rsp, err := c.c.Call(ctx, req, opts...)

	message.PutMessagePacket(req)
	if err != nil {
		return nil, err
	}
	m0 := rsp.Messages[0]
	message.PutMessagePacket(rsp)

	if c.usingGRPC {
		if m0.Uri != c.urinetutilsCmdCheckup {
			return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.urinetutilsCmdCheckup)
		}
		return m0.Message.(*netutils.CmdCheckup), nil
	}
	if m0.Uri == c.uriErrType {
		return nil, m0.Message.(error)
	}

	if m0.Uri != c.urinetutilsCmdCheckup {
		return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.urinetutilsCmdCheckup)
	}
	return m0.Message.(*netutils.CmdCheckup), nil
}
func (c *proxyRpcClientInternalCmd) CmdBuildStream(ctx context.Context, in *CmdStream, opts ...client.CallOption) (*CmdStream, error) {

	if c.usingGRPC {
		ctx = context.WithValue(ctx, "context-key-grpc-uri", "/netutils.InternalCmd/CmdBuildStream")
		ctx = context.WithValue(ctx, "context-key-grpc-response-pointer", new(CmdStream))
	}

	req := message.GetMessagePacket()
	req.Messages = message.Messages{&message.Message{Message: in, Uri: "/netutils.InternalCmd/CmdBuildStream"}}

	req.Version = 1

	rsp, err := c.c.Call(ctx, req, opts...)

	message.PutMessagePacket(req)
	if err != nil {
		return nil, err
	}
	m0 := rsp.Messages[0]
	message.PutMessagePacket(rsp)

	if c.usingGRPC {
		if m0.Uri != c.uriCmdStream {
			return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.uriCmdStream)
		}
		return m0.Message.(*CmdStream), nil
	}
	if m0.Uri == c.uriErrType {
		return nil, m0.Message.(error)
	}

	if m0.Uri != c.uriCmdStream {
		return nil, serror.NewText("return invalid type: %s,expect:%s", m0.Uri, c.uriCmdStream)
	}
	return m0.Message.(*CmdStream), nil
}
